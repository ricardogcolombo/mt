\begin{algorithm}[H]
\caption{Find Minimum Spanning Tree}
\begin{algorithmic}[1]
\Function{Prim}{Lista de vertices $vertices$, Lista de aristas $aristas$} \Comment $\mathcal{O}(n + m*log(n))$
	\For{$0 \leq i < |vertices|$}
		\State $visitado[i] \gets false$
		\State $distancia[i] \gets INF$
		\State $padre[i] \gets i$
	\EndFor
	\Statex
	\State $\_distancia[0] \gets 0$ \Comment empezamos por el primer nodo de la lista
	\State $\_padre[0] \gets 0$
	\State $\_colaMinPrioridad.push(0, \_distancia[0])$
	\Statex
	\While{$\_colaMinPrioridad \neq \varnothing$}
		\State $p \gets \_colaMinPrioridad.extraerMinimo()$
		\If{$\neg \_visitado[p]$}
			\State $\_visitado[p] = true$
			\For{$0 \leq i < points$}
				\If{$i \neq p \land \exists e \in ejes, e.u = p \land e.v = i$}
					\If{$\neg \_visitado[i] \land \_distancia[i] > peso(p, i)$}
						\State $\_distancia[i] = peso(p, i)$
						\State $\_padre[i] = p$
						\State $\_colaMinPrioridad.push(i, \_distancia[i])$
					\EndIf
				\EndIf
			\EndFor
		\EndIf
	\EndWhile
	\Statex
	\State \Return $\_padre$
\EndFunction
\end{algorithmic}
\end{algorithm}