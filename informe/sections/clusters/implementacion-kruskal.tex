\subsubsection{Kruskal}
El algoritmo de Kruskal es uno de los algoritmos para dar un árbol generador mínimo dado un grafo con peso asignado a sus aristas, en este caso, el peso será la distancia euclidiana

En primer lugar, se procede a ordenar la lista $edges$ por el peso de los ejes y de manera creciente. Este ordenamiento dispone de una complejidad $\mathcal{O}(n * log(n))$. A continuación procederemos a construir el árbol generador mínimo, por lo tanto es necesario comenzar por los ejes de menor peso para poder asegurar la \textbf{condición mínima} de nuestro árbol generador. Los ejes de este último se guardarán en la lista $min\_spanning\_tree$. Ahora, un eje del grafo $G$ formará parte del árbol generador mínimo si al agregarlo a $min\_spanning\_tree$, \textbf{no forma un ciclo} entre los ejes que ya estaban ahí. Esto levanta una nueva incógnita: ¿Cómo decidimos si un eje forma un ciclo con otros? Para resolver esta pregunta, se dispone de una estructura de datos llamada \textbf{Disjoint Set Union}.

\subsubsubsection{Disjoint Set Union}
El propósito de esta estructura es llevar la cuenta de a qué componentes conexas pertenece cada vértice en el grafo. En otras palabras, es una estructura que nos permite contabilizar conjuntos disjuntos de vértices a través de la designación de \textbf{representantes} en las componentes conexas. Esta estructura nos provee la siguiente interfaz:
\begin{itemize}
	\item find$(x)$: Dado un elemento $x$, retorna el representante del vértice. Es decir, un identificador de la componente conexa a la cual pertenece $x$.
 	\item union$(x, y)$: Une a $x$ e $y$ y por transitividad a las componentes conexas de ambos.
\end{itemize}

Además, esta estructura cuenta con una variante llamada \textbf{Path Compression} que consiste en recordar en un arreglo el representante de un nodo buscado a través de $find$ para poder accederlo en $\mathcal{O}(\alpha(m))$ en la próxima consulta, con $\alpha$ la función inversa de Ackermann.