\begin{algorithm}[H]
\caption{Find Minimum Spanning Tree}
\begin{algorithmic}[1]
\Function{Kruskal}{$points \in \mathbb{N}$,$vector<Eje> ejes$} 				\Comment $\mathcal{O}(n + m*log(n))$
	\State $agm = \varnothing$ 
	\Statex
	\State \textbf{Inicializar} $DisjointSetUnion$ 						
	\State $Sort(ejes)$ 												
	\For{$e \in ejes$} 													
		\If{$DisjointSetUnion.find(e.v) \ne DisjointSetUnion.find(e.u)$}
			\State $agm \gets agm \cup e$
			\State $DisjointSetUnion.union(e.v, e.u)$
		\EndIf
	\EndFor
	\Statex
	\State \Return $agm$
\EndFunction
\end{algorithmic}
\end{algorithm}

La complejidad del algoritmo se asume utilizando Disjoint Set Union con path compression, si no se la usara, ni la optimización de \textit{padres de vértices}, una operación \textbf{find} o \textbf{union} puede tomar $\mathcal{O}(n)$. Si bien $m = n*(n-1)$ porque se trabaja con un grafo completo, podemos concluir que $\mathcal{O}(n + m*log(m)) = \mathcal{O}(n + m*log(n^2)) = \mathcal{O}(n + m*2*log(n)) = \mathcal{O}(n + m*log(n))$ y esta cota obtenida es más preferible pues es más ajustada.
