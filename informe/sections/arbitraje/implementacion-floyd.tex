\subsection{Floyd-Warshall}
\subsubsubsection{Resolución} \label{res-floyd}
El algoritmo de Floyd-Warshall es un algoritmo matricial que calcula la distancia entre todos los distintos nodos. Dado que la entrada del ejercicio es la matriz de tipos de cambio, podemos tomar a la misma como la matriz de entrada para el algoritmo, llamemosla L. Donde cada $`$i', $`$j' de la matriz representa el peso de la arista desde el nodo $`$i' a $`$j'. Sea l(ij) la funcion que define este peso.

Como parte del ejercicio es devolver el ciclo de arbitraje encontrado, debemos tener una manera de reconstruir dicho ciclo. Para ello, utilizaremos la matriz $``$next", una matriz de sucesores, que tiene el mismo tamaño que la matriz de entrada. La matriz $``$next" es inicializada con cada nodo indicando a si mismo como su sucesor.

Una vez que tenemos la matriz de sucesores, procedemos a resolver el camino máximo del grafo. Para ello, el algoritmo de Floyd-Warshall recurre a tres ciclos anidados donde recorremos la matriz. La idea es trabajar con una matriz $``$virtual" representada en la iteracion del ciclo principal, que llamaremos $`$k'. Los otros dos ciclos recorren el valor de $`$i' en el primer caso y el de $`$j' en el ciclo interno. Por cuestiones de complejidad temporal, Floyd-Warshall nos permite siempre trabajar sobre la matriz inicial, sin necesidad de crear una nueva para cada paso. En cada paso del ciclo $`$k', que itera el valor de $`$k' entre 0 y $`$n', el algoritmo calcula el camino máximo de un vertice $`$i' a otro $`$j' con vertices intermedios en el conjunto $``${0,....,k}".

$L^{k}$ es la matriz del paso $`$k'. Lo cual nos permite la siguiente definicion:

- $L^{0}[i][j]$ = 0 y para i$neq$j, $L^{0}[i][j]$ = l(ij) si ij pertence a los ejes del grafo. En este caso, el grafo es completo asi que el eje siempre existe.

- $L^{k+1}[i][j]$ = max{$L^{k}[i][j]$, $L^{k}[i][k]$ * $L^{k}[k][j]$}. Esta funcion no es la original del algoritmo de Floyd-Warshall, ya que aquí buscamos maximizar la longitud del camino. Esto es válido de la misma forma que la variante de Bellman-Ford presente en este trabajo práctico. Podemos encontrar la justificación de la utilización del producto en la sección 2.2.0.2, es decir, la misma justificación que Bellman-Ford. En este paso, tambien actualizamos el valor de la matriz de sucesores en caso de que el valor maximo sea el del segundo argumento. En dicho caso, como el camino del nodo $`$i' a $`$j' necesita pasar primero por el nodo $`$k', podemos decir que el camino es igual al camino de $`$i' a $`$k'.

La matriz buscada es $L^{n}$.

Al final de cada iteracion del ciclo $`$j', el algoritmo verifica si el elemento en la posicion $[i][i]$ es mayor a 1. Esto es equivalente a buscar si se formo el ciclo de arbitraje. Esto se hace al final de cada iteracion de $`$j' porque significa que ya actualizamos la distancia del nodo $`$i' a todos los demas, por eso queremos ver si en esta modificacion obtuvimos un ciclo de arbitraje. Al encontrar dicho ciclo pasamos a reconstruir el mismo, en caso de que no se encuentre, el algortimo habra iterado los tres ciclos por completo. Como $`$k', $`$i' y $`$j' iteran entre 0 y $`$n', iterar los tres por completo nos presenta la complejidad $\mathcal{O}(n^{3})$ del algoritmo.

Reconstruir el ciclo solo nos presenta complejidad $\mathcal{O}(n)$. El mismo recorre el camino formado en la matriz de sucesores. Tomamos como punto de partida el nodo $next[i][i]$. Obteniendo ese valor, que llamaremos $`$suc', lo que queremos es pedir el siguiente del nodo $[suc][i]$, para reconstruir el camino desde el sucesor ($`$suc') hasta $`$i' nuevamente.

\begin{algorithm}[H]
	\caption{arbitraje(Matriz cotizaciones, int n) res: vector<int> cicloArbitraje}
	\begin{algorithmic}[1]
		\State $vector<int> cicloArbitraje$ \Comment $\mathcal{O}(n)$
		\State $Matriz<int, int> sucesores \gets getNextElementMatrix(n)$ \Comment $\mathcal{O}(n^{2})$
		\For{$k = 0, n$} \Comment $\mathcal{O}(n^{3} + n)$
			\For{$i = 0, n$}
				\For{$j = 0, n$}
					\State $distanciaCalculada \gets cotizaciones[i][k] * cotizaciones[k][j]$
					\If{$cotizaciones[i][j] < distanciaCalculada$}
						\State $cotizaciones[i][j] \gets distanciaCalculada$
						\State $sucesores[i][j] \gets sucesores[i][k]$
					\EndIf
				\EndFor
				\If{$cotizaciones[i][j] > 1$}
					\State \textbf{return} $computeArbitrajeCycle(sucesores, i)$
				\EndIf
			\EndFor
		\EndFor
		\State \textbf{return} $cicloArbitraje$
	\end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]
	\caption{getNextElementMatrix(int n) res: Matriz sucesores}
	\begin{algorithmic}[1]
		\State $Matriz<int, int> sucesores$
		\For{$i = 0, n$} \Comment $\mathcal{O}(n^{2})$
			\For{$j = 0, n$}
				\State $sucesores[i][j] \gets j$
			\EndFor
		\EndFor
		\State \textbf{return} $sucesores$
	\end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]
	\caption{computeArbitrajeCycle(Matriz sucesores, int i) res: Matriz sucesores}
	\begin{algorithmic}[1]
		\State $vector<int> cicloArbitraje$
		\State $suc \gets sucesores[i][i]$
		\State $cicloArbitraje.push_back(i)$
		\While{$suc \neq i$} \Comment $\mathcal{O}(n)$
			\State $cicloArbitraje.push_back(suc)$
			\State $suc \gets sucesores[r][i]$
		\EndWhile
		\State $cicloArbitraje.push_back(i)$
		\State \textbf{return} $sucesores$
	\end{algorithmic}
\end{algorithm}