\subsubsection{Prim}
Prim es uno de los algoritmos utilizados para generar un AGM. Lo implementaremos usando una cola de prioridad.
Como parámetros de entrada contaremos con:

\begin{itemize}
	\item $vertices$: todos los nodos del grafo
	\item $aristas$: todos los ejes del grafo, con sus respectivos pesos
\end{itemize}

A continuación se muestra el pseudo-código del algoritmo:
\input{sections/clusters/implementacion-prim-code}

Como primer paso, inicializamos tres arreglos de longitud n, con el i-ésimo elemento representando al i-ésimo punto del grafo.
Uno para vértices ya visitados, de boleanos, que comienza todo en false e indica si el vértice ya fue visitado.
Otro de distancias, que indica la distancia del nodo a la raíz del árbol que estamos generando.
Y finalmente uno de padres, donde $ i, j in mathcal{N}, padres[i]=j$ representa el eje entre el i-ésimo y el j-ésimo nodo, y que por construcción es el de menor peso explorado, y por lo tanto es mínimo. Esta lista de ejes será la herramienta principal para reconstruir el AGM que estamos buscando.

El vector de visitados nos permita asegurar que no generaremos ciclos. Al extraer un elemento de la cola de prioridad, se verifica que éste no haya sido visitado utilizando el vector antes mencionado. Si ya fue visitado, se ignora ese valor de la cola de prioridad y se procede a extraer el próximo. En caso de no haber sido visitado se compara la distancia global del árbol al vértice, si fuera esta menor entonces se lo marca como visitado y se registra su relación con el resto del AGM mediante el vector de padres, además de actualizar las distancias pertinentes. Al recorrer los ejes del grafo $G$ y usar la cola mínima de prioridad, cuyas operaciones son logarítmicas, para formar el AGM, la complejidad final es de $\mathcal{O}(m log(n))$